<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/web-animations-js/web-animations-next-lite.min.html">

<dom-module id="element-tester">
	<template>
		<style>
			:host {
				margin: 8px;
				@apply --layout-vertical;
			}

			#controls {
				margin-top: 8px;
				padding: 0 4px;
				background: #ebebeb;
				border-radius: 3px;
				box-shadow: 0 0 2px 2px rgba(0, 0, 0, .2);
				min-width: 200px;
				@apply --element-tester-controls;
				@apply --layout-horizontal;
				@apply --layout-wrap;
			}

			.control {
				width: 50%;
				box-sizing: border-box;
				padding: 0 4px;
			}

			.prefix {
				margin-right: 8px;
			}

			paper-item {
				cursor: pointer;
			}

			paper-input[type="checkbox"] {
				cursor: pointer;
				user-select: none;
			}
		</style>

		<div id="element">
			<slot id="elementSlot"></slot>
		</div>

		<div id="controls"></div>
	</template>

	<script>
		// TODO: elementTester.enum
		class ElementTester extends Polymer.Element {
			static get is() {
				return 'element-tester';
			}

			static get properties() {
				return {};
			}

			static calcPropertyInputType(propertyType) {
				switch (propertyType) {
					case String:
						return 'text';
					case Number:
						return 'number';
					case Boolean:
						return 'checkbox';
					default:
						return 'text';
				}
			}

			static createPropertyInput(element, propertyName, property) {
				let input;
				let valuePrefix;

				const elementTesterOpts = property.elementTester || {};
				if (elementTesterOpts.enum) {
					input = document.createElement('paper-dropdown-menu');

					const listBox = document.createElement('paper-listbox');
					listBox.slot = 'dropdown-content';
					listBox.selected = 0;

					property.elementTester.enum.forEach(allowedValue => {
						const item = document.createElement('paper-item');
						item.value = allowedValue;
						item.innerText = allowedValue;
						listBox.appendChild(item);
					});

					input.appendChild(listBox);
				} else {
					input = document.createElement('paper-input');
					input.type = ElementTester.calcPropertyInputType(property.type);

					if (elementTesterOpts.type) {
						input.type = property.elementTester.type;
					}

					if (input.type === 'color' || input.type === 'checkbox') {
						valuePrefix = document.createElement('div');
						valuePrefix.classList.add('prefix');
						valuePrefix.slot = 'prefix';
						valuePrefix.setAttribute('prefix', true);
						valuePrefix.innerText = property.value;
						input.appendChild(valuePrefix);
					}

					if (input.type === 'checkbox') {
						input.alwaysFloatLabel = true;
						input.addEventListener('click', () => {
							input.value = !input.value;
						});
					}

					input.setAttribute('type', input.type);
				}

				input.label = propertyName;
				input.value = property.value;
				input.classList.add('control');

				input.addEventListener('value-changed', e => {
					let newValue = e.detail.value;
					if (e.target.type === 'number') {
						newValue = parseFloat(newValue);
					} else if (e.target.type === 'checkbox') {
						if (newValue === 'false') {
							newValue = false;
						} else if (newValue === 'true') {
							newValue = true;
						}
						newValue = Boolean(newValue);
					}

					if (valuePrefix) {
						valuePrefix.innerText = newValue;
					}

					element[propertyName] = newValue;
				});

				return input;
			}

			ready() {
				super.ready();
				this._elementSlotObserver = new Polymer.FlattenedNodesObserver(this.$.elementSlot, info => {
					this._removeInputs();
					const firstElementNode = info.addedNodes.find(addedNode => addedNode.nodeName !== '#text');
					if (firstElementNode) {
						Polymer.RenderStatus.beforeNextRender(this, () => {
							this._attachToElement(firstElementNode);
						});
					}
				});
			}

			_attachToElement(element) {
				const props = Object.entries(element.constructor.properties)
					.filter(([_, propDecl]) => {
						return !propDecl.readOnly &&
							!propDecl.computed &&
							typeof propDecl.value !== 'function';
					});
				props.forEach(([propName, propDecl]) => {
					const input = ElementTester.createPropertyInput(element, propName, propDecl);
					this.$.controls.appendChild(input);
				});
			}

			_removeInputs() {
				this.$.controls.innerHTML = '';
			}
		}

		customElements.define(ElementTester.is, ElementTester);
	</script>
</dom-module>
